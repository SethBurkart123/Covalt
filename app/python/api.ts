/* Auto-generated by Zynk - DO NOT EDIT */
/* Generated: 2026-01-18T12:57:11.113324 */

import { initBridge, BridgeRequestError, request, createChannel, createUpload, getBaseUrl } from "./_internal";
import type { BridgeError, BridgeChannel, UploadHandle, UploadProgressEvent } from "./_internal";

export { initBridge, BridgeRequestError };
export type { BridgeError, BridgeChannel, UploadHandle, UploadProgressEvent };

// ============ Interfaces ============

/**
 * Information about an active stream.
 */
export interface ActiveStreamInfo {
    chatId: string;
    messageId: string;
    status: string;
    errorMessage?: string | undefined;
}

/**
 * Response containing all active streams.
 */
export interface ActiveStreamsResponse {
    streams: ActiveStreamInfo[];
}

/**
 * Input for adding a new MCP server.
 */
export interface AddMCPServerInput {
    id: string;
    config: MCPServerConfig;
}

export interface AgentConfig {
    provider?: string;
    modelId?: string;
    toolIds?: string[];
    instructions?: string[];
    name?: string | undefined;
    description?: string | undefined;
}

export interface AllChatsData {
    chats: Record<string, ChatData>;
}

export interface AllModelSettingsResponse {
    models: ModelSettingsInfo[];
}

export interface AllProvidersResponse {
    providers: ProviderConfig[];
}

/**
 * Model for file attachments on messages.
 */
export interface Attachment {
    id: string;
    type: unknown;
    name: string;
    mimeType: string;
    size: number;
}

export interface AttachmentDataResponse {
    data: string;
    mimeType: string;
}

/**
 * Incoming attachment with base64 data (for new attachments).
 */
export interface AttachmentInput {
    id: string;
    type: string;
    name: string;
    mimeType: string;
    size: number;
    data: string;
}

/**
 * Attachment metadata without base64 data (files are pre-uploaded).
 */
export interface AttachmentMeta {
    id: string;
    type: string;
    name: string;
    mimeType: string;
    size: number;
}

export interface AutoTitleSettings {
    enabled?: boolean;
    prompt?: string;
    modelMode?: string;
    provider?: string;
    modelId?: string;
}

export interface AvailableModelsResponse {
    models: ModelInfo[];
}

export interface AvailableToolsResponse {
    tools?: ToolInfo[];
}

export interface CancelRunRequest {
    messageId: string;
}

export interface ChatAgentConfigResponse {
    toolIds: string[];
    provider: string;
    modelId: string;
}

export interface ChatData {
    id?: string | undefined;
    title: string;
    messages?: ChatMessage[];
    model?: string | undefined;
    createdAt?: string | undefined;
    updatedAt?: string | undefined;
    starred?: boolean;
}

export interface ChatId {
    id: string;
}

export interface ChatMessage {
    id: string;
    role: string;
    content: string | ContentBlock[];
    createdAt?: string | undefined;
    toolCalls?: ToolCall[] | undefined;
    attachments?: Attachment[] | undefined;
}

/**
 * Request to clear a stream record (after user acknowledges).
 */
export interface ClearStreamRequest {
    chatId: string;
}

export interface ContentBlock {
    type: string;
    content?: string | undefined;
    id?: string | undefined;
    toolName?: string | undefined;
    toolArgs?: Record<string, unknown> | undefined;
    toolResult?: string | undefined;
    isCompleted?: boolean | undefined;
    renderer?: string | undefined;
    requiresApproval?: boolean | undefined;
    approvalId?: string | undefined;
    approvalStatus?: string | undefined;
}

export interface ContinueMessageRequest {
    messageId: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
}

export interface CreateChatInput {
    id?: string | undefined;
    title?: string | undefined;
    model?: string | undefined;
    agentConfig?: AgentConfig | undefined;
}

export interface DbPathResponse {
    path: string;
}

export interface DefaultToolsResponse {
    toolIds: string[];
}

/**
 * Request to delete a pending attachment.
 */
export interface DeletePendingRequest {
    id: string;
    mimeType: string;
}

export interface EditUserMessageRequest {
    messageId: string;
    newContent: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
    existingAttachments?: ExistingAttachmentInput[];
    newAttachments?: AttachmentInput[];
}

/**
 * Request to enable/disable a toolset.
 */
export interface EnableToolsetRequest {
    id: string;
    enabled: boolean;
}

/**
 * Existing attachment (just metadata, file already saved).
 */
export interface ExistingAttachmentInput {
    id: string;
    type: string;
    name: string;
    mimeType: string;
    size: number;
}

/**
 * Response containing exported toolset ZIP as base64.
 */
export interface ExportToolsetResponse {
    filename: string;
    data: string;
}

export interface GetAttachmentInput {
    chatId: string;
    attachmentId: string;
    mimeType: string;
    name: string;
}

export interface GetMessageSiblingsRequest {
    messageId: string;
}

export interface Greeting {
    message: string;
}

/**
 * Result of importing a toolset.
 */
export interface ImportToolsetResult {
    id: string;
    name: string;
    version: string;
    toolCount: number;
}

/**
 * Configuration for an MCP server.
 */
export interface MCPServerConfig {
    command?: string | undefined;
    args?: string[] | undefined;
    env?: Record<string, string> | undefined;
    cwd?: string | undefined;
    url?: string | undefined;
    transport?: unknown | undefined;
    headers?: Record<string, string> | undefined;
    requiresConfirmation?: boolean;
    toolOverrides?: Record<string, Record<string, unknown>> | undefined;
}

/**
 * Input containing just a server ID.
 */
export interface MCPServerId {
    id: string;
}

/**
 * Information about an MCP server.
 */
export interface MCPServerInfo {
    id: string;
    status: unknown;
    error?: string | undefined;
    toolCount?: number;
    tools?: MCPToolInfo[];
    config?: Record<string, unknown>;
}

/**
 * Response for get_mcp_servers.
 */
export interface MCPServersResponse {
    servers: MCPServerInfo[];
}

/**
 * Information about an MCP tool.
 */
export interface MCPToolInfo {
    id: string;
    name: string;
    description?: string | undefined;
    inputSchema?: Record<string, unknown> | undefined;
    renderer?: string | undefined;
    editableArgs?: string[] | undefined;
    requiresConfirmation?: boolean;
}

/**
 * Status update for a single MCP server.
 */
export interface McpServerStatus {
    id: string;
    status: string;
    error?: string | undefined;
    toolCount?: number;
}

/**
 * Full snapshot of all MCP servers.
 */
export interface McpServersSnapshot {
    servers: McpServerStatus[];
}

export interface MessageSiblingInfo {
    id: string;
    sequence: number;
    isActive: boolean;
}

export interface ModelInfo {
    provider: string;
    modelId: string;
    displayName: string;
    isDefault?: boolean;
}

export interface ModelSettingsInfo {
    provider: string;
    modelId: string;
    parseThinkTags: boolean;
    reasoning: ReasoningInfo;
    thinkingTagPrompted?: ThinkingTagPromptInfo | undefined;
}

export interface Person {
    name: string;
}

/**
 * Client ping to keep connection alive.
 */
export interface Ping {
}

export interface ProviderConfig {
    provider: string;
    apiKey?: string | undefined;
    baseUrl?: string | undefined;
    extra?: unknown | undefined;
    enabled?: boolean;
}

export interface ReasoningInfo {
    supports: boolean;
    isUserOverride: boolean;
}

export interface RespondToThinkingTagPromptInput {
    provider: string;
    modelId: string;
    accepted: boolean;
}

export interface RespondToToolApprovalInput {
    runId: string;
    approved: boolean;
    toolDecisions?: Record<string, boolean> | undefined;
    editedArgs?: Record<string, Record<string, unknown>> | undefined;
}

export interface RetryMessageRequest {
    messageId: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
}

export interface SaveAutoTitleSettingsInput {
    enabled: boolean;
    prompt: string;
    modelMode: string;
    provider: string;
    modelId: string;
}

export interface SaveModelSettingsInput {
    provider: string;
    modelId: string;
    parseThinkTags?: boolean;
    reasoning?: ReasoningInfo | undefined;
}

export interface SaveProviderConfigInput {
    provider: string;
    apiKey?: string | undefined;
    baseUrl?: string | undefined;
    extra?: unknown | undefined;
    enabled?: boolean;
}

export interface SetDefaultToolsInput {
    toolIds: string[];
}

export interface StreamChatRequest {
    messages: Record<string, unknown>[];
    modelId?: string | undefined;
    chatId?: string | undefined;
    toolIds?: string[];
    attachments?: AttachmentMeta[];
}

/**
 * Request to subscribe to a stream.
 */
export interface SubscribeToStreamRequest {
    chatId: string;
}

export interface SwitchToSiblingRequest {
    messageId: string;
    siblingId: string;
    chatId: string;
}

/**
 * Input for testing provider connection.
 */
export interface TestProviderInput {
    provider: string;
}

/**
 * Response from testing provider connection.
 */
export interface TestProviderResponse {
    success: boolean;
    error?: string | undefined;
}

export interface ThinkingTagPromptInfo {
    prompted: boolean;
    declined: boolean;
}

export interface ToggleChatToolsInput {
    chatId: string;
    toolIds: string[];
}

export interface ToolCall {
    id: string;
    toolName: string;
    toolArgs: Record<string, unknown>;
    toolResult?: string | undefined;
    isCompleted?: boolean | undefined;
}

export interface ToolInfo {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    inputSchema?: Record<string, unknown> | undefined;
    renderer?: string | undefined;
    editableArgs?: string[] | undefined;
    requiresConfirmation?: boolean | undefined;
}

/**
 * Detailed toolset information including tools.
 */
export interface ToolsetDetailInfo {
    id: string;
    name: string;
    version: string;
    description?: string | undefined;
    enabled?: boolean;
    installedAt?: string | undefined;
    sourceType?: string | undefined;
    toolCount?: number;
    tools?: ToolInfo[];
}

/**
 * Request containing just a toolset ID.
 */
export interface ToolsetIdRequest {
    id: string;
}

/**
 * Information about a toolset.
 */
export interface ToolsetInfo {
    id: string;
    name: string;
    version: string;
    description?: string | undefined;
    enabled?: boolean;
    installedAt?: string | undefined;
    sourceType?: string | undefined;
    toolCount?: number;
}

/**
 * Response for list_toolsets.
 */
export interface ToolsetsResponse {
    toolsets: ToolsetInfo[];
}

export interface UpdateChatInput {
    id: string;
    title?: string | undefined;
    model?: string | undefined;
}

export interface UpdateChatModelInput {
    chatId: string;
    provider: string;
    modelId: string;
}

/**
 * Input for updating an MCP server.
 */
export interface UpdateMCPServerInput {
    id: string;
    config: MCPServerConfig;
}

/**
 * Request to update/create a file in the workspace.
 */
export interface UpdateWorkspaceFileRequest {
    chatId: string;
    path: string;
    content: string;
}

/**
 * Response after updating a workspace file.
 */
export interface UpdateWorkspaceFileResponse {
    manifestId: string;
    path: string;
}

/**
 * Result of uploading an attachment.
 */
export interface UploadAttachmentResult {
    id: string;
    type: string;
    name: string;
    mimeType: string;
    size: number;
}

/**
 * Request for a specific workspace file.
 */
export interface WorkspaceFileRequest {
    chatId: string;
    path: string;
}

/**
 * Response with workspace file content.
 */
export interface WorkspaceFileResponse {
    path: string;
    content: string;
    size: number;
}

/**
 * Notification that workspace files have changed.
 */
export interface WorkspaceFilesChanged {
    chatId: string;
    changedPaths: string[];
    deletedPaths: string[];
}

/**
 * Request for workspace file operations.
 */
export interface WorkspaceFilesRequest {
    chatId: string;
}

/**
 * Response listing workspace files.
 */
export interface WorkspaceFilesResponse {
    files: string[];
}

/**
 * Request for workspace manifest.
 */
export interface WorkspaceManifestRequest {
    chatId: string;
    manifestId?: string | undefined;
}

/**
 * Response with workspace manifest info.
 */
export interface WorkspaceManifestResponse {
    id: string;
    chatId: string;
    parentId?: string | undefined;
    files: Record<string, string>;
    createdAt?: string | undefined;
    source: string;
}


// ============ Commands ============

/**
 * Add a new MCP server and connect to it.
 * 
 * Args:
 * body: Contains server ID and configuration
 * 
 * Returns:
 * Server info with connection status
 */
export async function addMcpServer(args: { body: AddMCPServerInput }): Promise<MCPServerInfo> {
    const _r = await request("add_mcp_server", { body: args.body });
    return { id: _r.id, status: _r.status, error: _r.error, toolCount: _r.toolCount, tools: _r.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, inputSchema: item.inputSchema, renderer: item.renderer, editableArgs: item.editable_args, requiresConfirmation: item.requires_confirmation })), config: _r.config };
}

/**
 * Cancel an active streaming run. Returns {cancelled: bool}
 */
export async function cancelRun(args: { body: CancelRunRequest }): Promise<unknown> {
    return request("cancel_run", { body: args.body });
}

/**
 * Clean up all pending uploads.
 * 
 * Manual cleanup endpoint for orphaned files.
 * 
 * Returns:
 * Number of files cleaned up
 */
export async function cleanupPendingUploadsCommand(): Promise<unknown> {
    return request("cleanup_pending_uploads_command", {});
}

/**
 * Clear a stream record from the database.
 * Called when user acknowledges an interrupted/error stream.
 */
export async function clearStreamRecord(args: { body: ClearStreamRequest }): Promise<unknown> {
    return request("clear_stream_record", { body: args.body });
}

/**
 * Continue incomplete assistant message by creating a sibling branch.
 */
export function continueMessage(args: { body: ContinueMessageRequest }): BridgeChannel<unknown> {
    return createChannel("continue_message", { body: args.body });
}

export async function createChat(args: { body: CreateChatInput }): Promise<ChatData> {
    return request("create_chat", { body: args.body });
}

export async function deleteChat(args: { body: ChatId }): Promise<void> {
    return request("delete_chat", { body: args.body });
}

/**
 * Delete a pending attachment.
 * 
 * Called when user removes an attachment before sending.
 * 
 * Args:
 * body: Contains attachment ID and mimeType
 * 
 * Returns:
 * Success status
 */
export async function deletePendingUpload(args: { body: DeletePendingRequest }): Promise<unknown> {
    return request("delete_pending_upload", { body: args.body });
}

/**
 * Edit user message by creating sibling with new content.
 */
export function editUserMessage(args: { body: EditUserMessageRequest }): BridgeChannel<unknown> {
    return createChannel("edit_user_message", { body: args.body });
}

/**
 * Enable or disable a toolset.
 * 
 * Args:
 * body: Contains toolset ID and enabled state
 * 
 * Returns:
 * Success status
 */
export async function enableToolset(args: { body: EnableToolsetRequest }): Promise<Record<string, unknown>> {
    return request("enable_toolset", { body: args.body });
}

/**
 * Export a toolset to a ZIP file.
 * 
 * Args:
 * body: Contains toolset ID
 * 
 * Returns:
 * Base64 encoded ZIP file data
 */
export async function exportToolset(args: { body: ToolsetIdRequest }): Promise<ExportToolsetResponse> {
    return request("export_toolset", { body: args.body });
}

/**
 * Generate and update title for a chat based on its first message.
 * 
 * Args:
 * body: Contains chatId
 * 
 * Returns:
 * Dict with the new title or None if generation failed
 */
export async function generateChatTitle(args: { body: ChatId }): Promise<Record<string, unknown>> {
    return request("generate_chat_title", { body: args.body });
}

/**
 * Get all active and recently completed/errored streams.
 * Used by frontend on initialization to discover running streams.
 */
export async function getActiveStreams(): Promise<ActiveStreamsResponse> {
    return request("get_active_streams", {});
}

export async function getAllChats(): Promise<AllChatsData> {
    return request("get_all_chats", {});
}

/**
 * Load an attachment file and return it as base64.
 * 
 * Args:
 * body: Contains chatId, name (filename), and mimeType
 * 
 * Returns:
 * Base64-encoded file data with mime type
 */
export async function getAttachment(args: { body: GetAttachmentInput }): Promise<AttachmentDataResponse> {
    return request("get_attachment", { body: args.body });
}

/**
 * Get auto-title generation settings.
 * 
 * Returns:
 * Auto-title settings including enabled, prompt, and model configuration
 */
export async function getAutoTitleSettings(): Promise<AutoTitleSettings> {
    return request("get_auto_title_settings", {});
}

/**
 * Get list of available models based on configured providers.
 * 
 * Fetches from all enabled providers in parallel for maximum speed.
 * 
 * Returns:
 * List of available models with provider, modelId, displayName, and isDefault
 */
export async function getAvailableModels(): Promise<AvailableModelsResponse> {
    return request("get_available_models", {});
}

/**
 * Get all available tools (builtin, MCP, and toolset).
 * 
 * Returns:
 * Response with:
 * - tools: Flat list of all tools
 */
export async function getAvailableTools(): Promise<AvailableToolsResponse> {
    const _r = await request("get_available_tools", {});
    return { tools: _r.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, category: item.category, inputSchema: item.inputSchema, renderer: item.renderer, editableArgs: item.editable_args, requiresConfirmation: item.requires_confirmation })) };
}

export async function getChat(args: { body: ChatId }): Promise<Record<string, unknown>> {
    return request("get_chat", { body: args.body });
}

/**
 * Get agent configuration for a chat (tools, provider, model).
 * 
 * Args:
 * body: Contains chatId
 * 
 * Returns:
 * Chat's agent configuration
 */
export async function getChatAgentConfig(args: { body: ChatId }): Promise<ChatAgentConfigResponse> {
    return request("get_chat_agent_config", { body: args.body });
}

/**
 * Get the database directory path for file access.
 * 
 * Returns:
 * The absolute path to the database directory
 */
export async function getDbPath(): Promise<DbPathResponse> {
    return request("get_db_path", {});
}

/**
 * Get default tool IDs for new chats.
 * 
 * Returns:
 * List of default tool IDs
 */
export async function getDefaultTools(): Promise<DefaultToolsResponse> {
    return request("get_default_tools", {});
}

/**
 * Get a single MCP server's configuration for editing.
 * 
 * Returns unsanitized config with actual environment variable values.
 * 
 * Args:
 * body: Contains server ID
 * 
 * Returns:
 * Server configuration dict
 */
export async function getMcpServerConfig(args: { body: MCPServerId }): Promise<Record<string, unknown>> {
    return request("get_mcp_server_config", { body: args.body });
}

/**
 * Get all MCP servers with their status and tools.
 * 
 * Returns list of servers including:
 * - Connection status (connecting, connected, error, disconnected)
 * - Error message if status is error
 * - List of available tools for connected servers
 * - Sanitized config (env vars hidden)
 */
export async function getMcpServers(): Promise<MCPServersResponse> {
    const _r = await request("get_mcp_servers", {});
    return { servers: _r.servers.map((item: unknown) => ({ id: item.id, status: item.status, error: item.error, toolCount: item.toolCount, tools: item.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, inputSchema: item.inputSchema, renderer: item.renderer, editableArgs: item.editable_args, requiresConfirmation: item.requires_confirmation })), config: item.config })) };
}

/**
 * Get all sibling messages for navigation UI.
 */
export async function getMessageSiblings(args: { body: GetMessageSiblingsRequest }): Promise<MessageSiblingInfo[]> {
    return request("get_message_siblings", { body: args.body });
}

/**
 * Get all model settings including reasoning capabilities.
 * 
 * Returns:
 * List of model settings with reasoning support flags
 */
export async function getModelSettings(): Promise<AllModelSettingsResponse> {
    return request("get_model_settings", {});
}

/**
 * Get all configured provider settings.
 * 
 * Returns:
 * List of provider configurations
 */
export async function getProviderSettings(): Promise<AllProvidersResponse> {
    return request("get_provider_settings", {});
}

/**
 * Get detailed information about a toolset including its tools.
 * 
 * Args:
 * body: Contains toolset ID
 * 
 * Returns:
 * Toolset info with list of tools
 */
export async function getToolset(args: { body: ToolsetIdRequest }): Promise<ToolsetDetailInfo> {
    const _r = await request("get_toolset", { body: args.body });
    return { id: _r.id, name: _r.name, version: _r.version, description: _r.description, enabled: _r.enabled, installedAt: _r.installed_at, sourceType: _r.source_type, toolCount: _r.tool_count, tools: _r.tools.map((item: unknown) => ({ toolId: item.tool_id, name: item.name, description: item.description, category: item.category, requiresConfirmation: item.requires_confirmation, enabled: item.enabled })) };
}

export async function getVersion(): Promise<string> {
    return request("get_version", {});
}

/**
 * Read a file from a chat's workspace.
 * 
 * Args:
 * body: Contains chat ID and file path
 * 
 * Returns:
 * File content (base64 encoded)
 */
export async function getWorkspaceFile(args: { body: WorkspaceFileRequest }): Promise<WorkspaceFileResponse> {
    return request("get_workspace_file", { body: { chat_id: args.body.chatId, path: args.body.path } });
}

/**
 * List all files in a chat's workspace.
 * 
 * Args:
 * body: Contains chat ID
 * 
 * Returns:
 * List of file paths
 */
export async function getWorkspaceFiles(args: { body: WorkspaceFilesRequest }): Promise<WorkspaceFilesResponse> {
    return request("get_workspace_files", { body: { chat_id: args.body.chatId } });
}

/**
 * Get a workspace manifest for a chat.
 * 
 * Args:
 * body: Contains chat ID and optional manifest ID
 * 
 * Returns:
 * Manifest info including file mappings
 */
export async function getWorkspaceManifest(args: { body: WorkspaceManifestRequest }): Promise<WorkspaceManifestResponse> {
    const _r = await request("get_workspace_manifest", { body: { chat_id: args.body.chatId, manifest_id: args.body.manifestId } });
    return { id: _r.id, chatId: _r.chat_id, parentId: _r.parent_id, files: _r.files, createdAt: _r.created_at, source: _r.source };
}

export async function greet(args: { body: Person }): Promise<Greeting> {
    return request("greet", { body: args.body });
}

/**
 * List all installed toolsets.
 * 
 * Returns list of toolsets with their basic info.
 */
export async function listToolsets(): Promise<ToolsetsResponse> {
    const _r = await request("list_toolsets", {});
    return { toolsets: _r.toolsets.map((item: unknown) => ({ id: item.id, name: item.name, version: item.version, description: item.description, enabled: item.enabled, installedAt: item.installed_at, sourceType: item.source_type, toolCount: item.tool_count })) };
}

/**
 * Reconnect to a failed or disconnected MCP server.
 * 
 * Args:
 * body: Contains server ID
 * 
 * Returns:
 * Server info with new connection status
 */
export async function reconnectMcpServer(args: { body: MCPServerId }): Promise<MCPServerInfo> {
    const _r = await request("reconnect_mcp_server", { body: args.body });
    return { id: _r.id, status: _r.status, error: _r.error, toolCount: _r.toolCount, tools: _r.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, inputSchema: item.inputSchema, renderer: item.renderer, editableArgs: item.editable_args, requiresConfirmation: item.requires_confirmation })), config: _r.config };
}

/**
 * Disconnect and remove an MCP server.
 * 
 * Args:
 * body: Contains server ID
 * 
 * Returns:
 * Success status
 */
export async function removeMcpServer(args: { body: MCPServerId }): Promise<Record<string, boolean>> {
    return request("remove_mcp_server", { body: args.body });
}

/**
 * Handle user response to thinking tag detection prompt.
 * 
 * If accepted, enables parse_think_tags setting.
 * If declined, stores thinkingTagPrompted: { prompted: true, declined: true } in extra.
 * 
 * Args:
 * body: User's response
 */
export async function respondToThinkingTagPrompt(args: { body: RespondToThinkingTagPromptInput }): Promise<void> {
    return request("respond_to_thinking_tag_prompt", { body: args.body });
}

/**
 * Respond to a tool approval request using Agno's native HITL API.
 * 
 * This stores the approval response and signals the waiting streaming handler
 * to continue the run with updated tool confirmations.
 */
export async function respondToToolApproval(args: { body: RespondToToolApprovalInput }): Promise<unknown> {
    return request("respond_to_tool_approval", { body: args.body });
}

/**
 * Create sibling message and retry generation.
 */
export function retryMessage(args: { body: RetryMessageRequest }): BridgeChannel<unknown> {
    return createChannel("retry_message", { body: args.body });
}

/**
 * Save auto-title generation settings.
 * 
 * Args:
 * body: Auto-title settings to save
 */
export async function saveAutoTitleSettings(args: { body: SaveAutoTitleSettingsInput }): Promise<void> {
    return request("save_auto_title_settings", { body: args.body });
}

/**
 * Save or update model settings (including reasoning support).
 * 
 * Args:
 * body: Model settings to save
 */
export async function saveModelSettings(args: { body: SaveModelSettingsInput }): Promise<void> {
    return request("save_model_settings", { body: args.body });
}

/**
 * Save or update provider settings.
 * 
 * Args:
 * body: Provider configuration to save
 */
export async function saveProviderSettings(args: { body: SaveProviderConfigInput }): Promise<void> {
    return request("save_provider_settings", { body: args.body });
}

/**
 * Set default tool IDs for new chats.
 * 
 * Args:
 * body: Contains list of tool IDs to set as defaults
 */
export async function setDefaultTools(args: { body: SetDefaultToolsInput }): Promise<void> {
    return request("set_default_tools", { body: args.body });
}

export function streamChat(args: { body: StreamChatRequest }): BridgeChannel<unknown> {
    return createChannel("stream_chat", { body: args.body });
}

/**
 * Subscribe to events for an already-running stream.
 * 
 * This allows new frontends (or page reloads) to receive
 * live events for an existing stream.
 */
export function subscribeToStream(args: { body: SubscribeToStreamRequest }): BridgeChannel<unknown> {
    return createChannel("subscribe_to_stream", { body: args.body });
}

/**
 * Switch active branch to different sibling.
 */
export async function switchToSibling(args: { body: SwitchToSiblingRequest }): Promise<void> {
    return request("switch_to_sibling", { body: args.body });
}

/**
 * Test if a provider connection is valid.
 * 
 * Uses each provider's built-in test_connection() function
 * which validates credentials and connectivity.
 * 
 * Args:
 * body: Contains provider name to test
 * 
 * Returns:
 * Success status and optional error message
 */
export async function testProvider(args: { body: TestProviderInput }): Promise<TestProviderResponse> {
    return request("test_provider", { body: args.body });
}

/**
 * Update active tools for a chat session.
 * 
 * Args:
 * body: Contains chatId and list of tool IDs to activate
 */
export async function toggleChatTools(args: { body: ToggleChatToolsInput }): Promise<void> {
    return request("toggle_chat_tools", { body: args.body });
}

export async function toggleStarChat(args: { body: ChatId }): Promise<ChatData> {
    return request("toggle_star_chat", { body: args.body });
}

/**
 * Uninstall a toolset.
 * 
 * Removes all database records and files for the toolset.
 * 
 * Args:
 * body: Contains toolset ID
 * 
 * Returns:
 * Success status
 */
export async function uninstallToolset(args: { body: ToolsetIdRequest }): Promise<Record<string, boolean>> {
    return request("uninstall_toolset", { body: args.body });
}

export async function updateChat(args: { body: UpdateChatInput }): Promise<ChatData> {
    return request("update_chat", { body: args.body });
}

/**
 * Switch the model/provider for a chat session.
 * 
 * Args:
 * body: Contains chatId, provider, and modelId
 */
export async function updateChatModel(args: { body: UpdateChatModelInput }): Promise<void> {
    return request("update_chat_model", { body: args.body });
}

/**
 * Update an MCP server configuration and reconnect.
 * 
 * Args:
 * body: Contains server ID and new configuration
 * 
 * Returns:
 * Server info with connection status
 */
export async function updateMcpServer(args: { body: UpdateMCPServerInput }): Promise<MCPServerInfo> {
    const _r = await request("update_mcp_server", { body: args.body });
    return { id: _r.id, status: _r.status, error: _r.error, toolCount: _r.toolCount, tools: _r.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, inputSchema: item.inputSchema, renderer: item.renderer, editableArgs: item.editable_args, requiresConfirmation: item.requires_confirmation })), config: _r.config };
}

/**
 * Update or create a file in a chat's workspace.
 * 
 * Creates a new manifest with source="edit" and updates the chat's
 * active_manifest_id. The file is written to the workspace directory
 * and stored in blob storage.
 * 
 * Args:
 * body: Contains chat ID, file path, and base64-encoded content
 * 
 * Returns:
 * New manifest ID and the file path
 */
export async function updateWorkspaceFile(args: { body: UpdateWorkspaceFileRequest }): Promise<UpdateWorkspaceFileResponse> {
    const _r = await request("update_workspace_file", { body: { chat_id: args.body.chatId, path: args.body.path, content: args.body.content } });
    return { manifestId: _r.manifest_id, path: _r.path };
}

// ============ Uploads ============

/**
 * Import a toolset from a ZIP file upload.
 * 
 * Args:
 * file: Uploaded ZIP file
 * 
 * Returns:
 * Imported toolset info
 */
export function importToolset(args: { file: File }): UploadHandle<ImportToolsetResult> {
    return createUpload("import_toolset", [args.file], {});
}

/**
 * Upload an attachment to pending storage.
 * 
 * Called immediately when user drops/selects a file.
 * Files are stored in pending storage until added to workspace when message is sent.
 * 
 * Args:
 * file: The uploaded file
 * id: Frontend-generated attachment ID
 * 
 * Returns:
 * Attachment metadata
 */
export function uploadAttachment(args: { file: File; id: string }): UploadHandle<UploadAttachmentResult> {
    return createUpload("upload_attachment", [args.file], { id: args.id });
}

// ============ WebSockets ============

export interface EventsServerEvents {
    mcp_status: McpServerStatus;
    mcp_servers: McpServersSnapshot;
    workspace_files_changed: WorkspaceFilesChanged;
}

export interface EventsClientEvents {
    ping: Ping;
}

/**
 * WebSocket handler for real-time app events.
 * 
 * On connect:
 * - Sends current MCP server snapshot
 * - Registers for status updates
 * 
 * Broadcasts:
 * - mcp_status: Individual server status changes
 * - mcp_servers: Full server list (on connect)
 */
export class EventsSocket {
    private ws: WebSocket | null = null;
    private listeners: Map<string, Set<(data: unknown) => void>> = new Map();
    private connectionListeners: Set<() => void> = new Set();
    private disconnectionListeners: Set<(event: CloseEvent) => void> = new Set();
    private errorListeners: Set<(error: Event) => void> = new Set();

    connect(): void {
        const baseUrl = getBaseUrl().replace(/^http/, 'ws');
        this.ws = new WebSocket(`${baseUrl}/ws/events`);

        this.ws.onopen = () => {
            this.connectionListeners.forEach(cb => cb());
        };

        this.ws.onclose = (event) => {
            this.disconnectionListeners.forEach(cb => cb(event));
        };

        this.ws.onerror = (error) => {
            this.errorListeners.forEach(cb => cb(error));
        };

        this.ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                const eventName = message.event;
                const data = message.data;
                const callbacks = this.listeners.get(eventName);
                if (callbacks) {
                    callbacks.forEach(cb => cb(data));
                }
            } catch (e) {
                console.error('[Zynk] Failed to parse WebSocket message:', e);
            }
        };
    }

    disconnect(): void {
        this.ws?.close();
        this.ws = null;
    }

    get isConnected(): boolean {
        return this.ws?.readyState === WebSocket.OPEN;
    }

    send<K extends keyof EventsClientEvents>(
        event: K,
        data: EventsClientEvents[K]
    ): void {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error('[Zynk] WebSocket is not connected');
        }
        this.ws.send(JSON.stringify({ event, data }));
    }

    on<K extends keyof EventsServerEvents>(
        event: K,
        callback: (data: EventsServerEvents[K]) => void
    ): () => void {
        const eventStr = event as string;
        if (!this.listeners.has(eventStr)) {
            this.listeners.set(eventStr, new Set());
        }
        const cb = callback as (data: unknown) => void;
        this.listeners.get(eventStr)!.add(cb);
        return () => {
            this.listeners.get(eventStr)?.delete(cb);
        };
    }

    onConnect(callback: () => void): () => void {
        this.connectionListeners.add(callback);
        return () => {
            this.connectionListeners.delete(callback);
        };
    }

    onDisconnect(callback: (event: CloseEvent) => void): () => void {
        this.disconnectionListeners.add(callback);
        return () => {
            this.disconnectionListeners.delete(callback);
        };
    }

    onError(callback: (error: Event) => void): () => void {
        this.errorListeners.add(callback);
        return () => {
            this.errorListeners.delete(callback);
        };
    }

    onMcpStatus(callback: (data: McpServerStatus) => void): () => void {
        return this.on("mcp_status", (_d) => callback({ id: _d.id, status: _d.status, error: _d.error, toolCount: _d.tool_count }));
    }

    onMcpServers(callback: (data: McpServersSnapshot) => void): () => void {
        return this.on("mcp_servers", (_d) => callback({ servers: _d.servers.map((item: unknown) => ({ id: item.id, status: item.status, error: item.error, toolCount: item.tool_count })) }));
    }

    onWorkspaceFilesChanged(callback: (data: WorkspaceFilesChanged) => void): () => void {
        return this.on("workspace_files_changed", (_d) => callback({ chatId: _d.chat_id, changedPaths: _d.changed_paths, deletedPaths: _d.deleted_paths }));
    }

    sendPing(data: Ping): void {
        this.send("ping", data);
    }
}

export function createEventsSocket(): EventsSocket {
    return new EventsSocket();
}