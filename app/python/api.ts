/* Auto-generated by Zynk - DO NOT EDIT */
/* Generated: 2026-01-23T18:01:15.524095 */

import { initBridge, BridgeRequestError, request, createChannel, createUpload, getBaseUrl } from "./_internal";
import type { BridgeError, BridgeChannel, UploadHandle, UploadProgressEvent } from "./_internal";

export { initBridge, BridgeRequestError };
export type { BridgeError, BridgeChannel, UploadHandle, UploadProgressEvent };

// ============ Interfaces ============

export interface ActiveStreamInfo {
    chatId: string;
    messageId: string;
    status: string;
    errorMessage?: string | undefined;
}

export interface ActiveStreamsResponse {
    streams: ActiveStreamInfo[];
}

/**
 * Input for adding a new MCP server.
 */
export interface AddMCPServerInput {
    id: string;
    config: MCPServerConfig;
}

export interface AgentConfig {
    provider?: string;
    modelId?: string;
    toolIds?: string[];
    instructions?: string[];
    name?: string | undefined;
    description?: string | undefined;
}

export interface AllChatsData {
    chats: Record<string, ChatData>;
}

export interface AllModelSettingsResponse {
    models: ModelSettingsInfo[];
}

export interface AllProvidersResponse {
    providers: ProviderConfig[];
}

export interface Attachment {
    id: string;
    type: unknown;
    name: string;
    mimeType: string;
    size: number;
}

export interface AttachmentDataResponse {
    data: string;
    mimeType: string;
}

export interface AttachmentInput {
    id: string;
    type: string;
    name: string;
    mimeType: string;
    size: number;
    data: string;
}

export interface AttachmentMeta {
    id: string;
    type: string;
    name: string;
    mimeType: string;
    size: number;
}

export interface AutoTitleSettings {
    enabled?: boolean;
    prompt?: string;
    modelMode?: string;
    provider?: string;
    modelId?: string;
}

export interface AvailableModelsResponse {
    models: ModelInfo[];
}

export interface AvailableToolsResponse {
    tools?: ToolInfo[];
}

export interface CancelRunRequest {
    messageId: string;
}

export interface ChatAgentConfigResponse {
    toolIds: string[];
    provider: string;
    modelId: string;
}

export interface ChatData {
    id?: string | undefined;
    title: string;
    messages?: ChatMessage[];
    model?: string | undefined;
    createdAt?: string | undefined;
    updatedAt?: string | undefined;
    starred?: boolean;
}

export interface ChatId {
    id: string;
}

export interface ChatMessage {
    id: string;
    role: string;
    content: string | ContentBlock[];
    createdAt?: string | undefined;
    toolCalls?: ToolCall[] | undefined;
    attachments?: Attachment[] | undefined;
}

export interface ClearStreamRequest {
    chatId: string;
}

export interface ContentBlock {
    type: string;
    content?: string | undefined;
    id?: string | undefined;
    toolName?: string | undefined;
    toolArgs?: Record<string, unknown> | undefined;
    toolResult?: string | undefined;
    isCompleted?: boolean | undefined;
    renderer?: string | undefined;
    requiresApproval?: boolean | undefined;
    approvalId?: string | undefined;
    approvalStatus?: string | undefined;
}

export interface ContinueMessageRequest {
    messageId: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
}

export interface CreateChatInput {
    id?: string | undefined;
    title?: string | undefined;
    model?: string | undefined;
    agentConfig?: AgentConfig | undefined;
}

export interface DbPathResponse {
    path: string;
}

export interface DefaultToolsResponse {
    toolIds: string[];
}

export interface DeletePendingRequest {
    id: string;
    mimeType: string;
}

export interface EditUserMessageRequest {
    messageId: string;
    newContent: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
    existingAttachments?: ExistingAttachmentInput[];
    newAttachments?: AttachmentInput[];
}

export interface EnableToolsetRequest {
    id: string;
    enabled: boolean;
}

export interface ExistingAttachmentInput {
    id: string;
    type: string;
    name: string;
    mimeType: string;
    size: number;
}

export interface ExportToolsetResponse {
    filename: string;
    data: string;
}

export interface GetAttachmentInput {
    chatId: string;
    attachmentId: string;
    mimeType: string;
    name: string;
}

export interface GetMessageSiblingsRequest {
    messageId: string;
}

export interface Greeting {
    message: string;
}

export interface ImportToolsetResult {
    id: string;
    name: string;
    version: string;
    toolCount: number;
}

export interface ListToolsetsRequest {
    userMcp?: boolean | undefined;
}

export interface MCPServerConfig {
    command?: string | undefined;
    args?: string[] | undefined;
    env?: Record<string, string> | undefined;
    cwd?: string | undefined;
    url?: string | undefined;
    transport?: unknown | undefined;
    headers?: Record<string, string> | undefined;
    requiresConfirmation?: boolean;
    toolOverrides?: Record<string, Record<string, unknown>> | undefined;
}

/**
 * Input containing just a server ID.
 */
export interface MCPServerId {
    id: string;
}

export interface MCPServerInfo {
    id: string;
    status: unknown;
    error?: string | undefined;
    toolCount?: number;
    tools?: MCPToolInfo[];
    config?: Record<string, unknown>;
}

export interface MCPServersResponse {
    servers: MCPServerInfo[];
}

export interface MCPToolInfo {
    id: string;
    name: string;
    description?: string | undefined;
    inputSchema?: Record<string, unknown> | undefined;
    renderer?: string | undefined;
    rendererConfig?: Record<string, unknown> | undefined;
    requiresConfirmation?: boolean;
}

export interface McpServerStatus {
    id: string;
    status: string;
    error?: string | undefined;
    toolCount?: number;
    oauthStatus?: string | undefined;
    oauthProviderName?: string | undefined;
    authHint?: string | undefined;
    config?: Record<string, unknown> | undefined;
}

export interface McpServersSnapshot {
    servers: McpServerStatus[];
}

export interface MessageSiblingInfo {
    id: string;
    sequence: number;
    isActive: boolean;
}

export interface ModelInfo {
    provider: string;
    modelId: string;
    displayName: string;
    isDefault?: boolean;
}

export interface ModelSettingsInfo {
    provider: string;
    modelId: string;
    parseThinkTags: boolean;
    reasoning: ReasoningInfo;
    thinkingTagPrompted?: ThinkingTagPromptInfo | undefined;
}

export interface OAuthCallbackErrorInput {
    state: string;
    error: string;
    errorDescription?: string | undefined;
}

export interface OAuthCallbackInput {
    code: string;
    state: string;
}

export interface OAuthCallbackResult {
    success: boolean;
    error?: string | undefined;
}

export interface OAuthStatusResult {
    status: unknown;
    hasTokens?: boolean;
    error?: string | undefined;
}

export interface Person {
    name: string;
}

export interface Ping {
}

export interface ProbeOAuthInput {
    url: string;
}

export interface ProbeOAuthResult {
    requiresOAuth: boolean;
    providerName?: string | undefined;
    resourceMetadataUrl?: string | undefined;
    error?: string | undefined;
}

export interface ProviderConfig {
    provider: string;
    apiKey?: string | undefined;
    baseUrl?: string | undefined;
    extra?: unknown | undefined;
    enabled?: boolean;
}

export interface ReasoningInfo {
    supports: boolean;
    isUserOverride: boolean;
}

export interface RespondToThinkingTagPromptInput {
    provider: string;
    modelId: string;
    accepted: boolean;
}

export interface RespondToToolApprovalInput {
    runId: string;
    approved: boolean;
    toolDecisions?: Record<string, boolean> | undefined;
    editedArgs?: Record<string, Record<string, unknown>> | undefined;
}

export interface RetryMessageRequest {
    messageId: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
}

export interface RevokeOAuthResult {
    success: boolean;
    error?: string | undefined;
}

export interface SaveAutoTitleSettingsInput {
    enabled: boolean;
    prompt: string;
    modelMode: string;
    provider: string;
    modelId: string;
}

export interface SaveModelSettingsInput {
    provider: string;
    modelId: string;
    parseThinkTags?: boolean;
    reasoning?: ReasoningInfo | undefined;
}

export interface SaveProviderConfigInput {
    provider: string;
    apiKey?: string | undefined;
    baseUrl?: string | undefined;
    extra?: unknown | undefined;
    enabled?: boolean;
}

export interface ScanImportSourcesResponse {
    results: Record<string, SourceScanResult>;
}

export interface ScannedServer {
    id: string;
    config: MCPServerConfig;
}

export interface SetDefaultToolsInput {
    toolIds: string[];
}

/**
 * Request to set/update a tool override.
 */
export interface SetToolOverrideRequest {
    toolsetId: string;
    toolId: string;
    renderer?: string | undefined;
    rendererConfig?: Record<string, unknown> | undefined;
    nameOverride?: string | undefined;
    descriptionOverride?: string | undefined;
    requiresConfirmation?: boolean | undefined;
    enabled?: boolean | undefined;
}

export interface SourceScanResult {
    servers: ScannedServer[];
    error?: string | undefined;
}

export interface StartOAuthInput {
    serverId: string;
    serverUrl: string;
    callbackPort?: number;
}

export interface StartOAuthResult {
    success: boolean;
    authUrl?: string | undefined;
    state?: string | undefined;
    error?: string | undefined;
}

export interface StreamChatRequest {
    messages: Record<string, unknown>[];
    modelId?: string | undefined;
    chatId?: string | undefined;
    toolIds?: string[];
    attachments?: AttachmentMeta[];
}

export interface SubscribeToStreamRequest {
    chatId: string;
}

export interface SwitchToSiblingRequest {
    messageId: string;
    siblingId: string;
    chatId: string;
}

export interface TestMCPToolInput {
    serverId: string;
    toolName: string;
    arguments?: Record<string, unknown>;
}

export interface TestMCPToolResult {
    success: boolean;
    result?: string | undefined;
    error?: string | undefined;
    durationMs?: number;
}

/**
 * Input for testing provider connection.
 */
export interface TestProviderInput {
    provider: string;
}

/**
 * Response from testing provider connection.
 */
export interface TestProviderResponse {
    success: boolean;
    error?: string | undefined;
}

export interface ThinkingTagPromptInfo {
    prompted: boolean;
    declined: boolean;
}

export interface ToggleChatToolsInput {
    chatId: string;
    toolIds: string[];
}

export interface ToolCall {
    id: string;
    toolName: string;
    toolArgs: Record<string, unknown>;
    toolResult?: string | undefined;
    isCompleted?: boolean | undefined;
}

export interface ToolInfo {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    inputSchema?: Record<string, unknown> | undefined;
    renderer?: string | undefined;
    editableArgs?: string[] | undefined;
    requiresConfirmation?: boolean | undefined;
}

/**
 * Response after setting a tool override.
 */
export interface ToolOverrideResponse {
    toolsetId: string;
    toolId: string;
    renderer?: string | undefined;
    rendererConfig?: Record<string, unknown> | undefined;
    nameOverride?: string | undefined;
    descriptionOverride?: string | undefined;
    requiresConfirmation?: boolean | undefined;
    enabled?: boolean;
}

export interface ToolsetDetailInfo {
    id: string;
    name: string;
    version: string;
    description?: string | undefined;
    enabled?: boolean;
    userMcp?: boolean;
    installedAt?: string | undefined;
    sourceType?: string | undefined;
    toolCount?: number;
    tools?: ToolInfo[];
}

export interface ToolsetIdRequest {
    id: string;
}

export interface ToolsetInfo {
    id: string;
    name: string;
    version: string;
    description?: string | undefined;
    enabled?: boolean;
    userMcp?: boolean;
    installedAt?: string | undefined;
    sourceType?: string | undefined;
    toolCount?: number;
}

export interface ToolsetsResponse {
    toolsets: ToolsetInfo[];
}

export interface UpdateChatInput {
    id: string;
    title?: string | undefined;
    model?: string | undefined;
}

export interface UpdateChatModelInput {
    chatId: string;
    provider: string;
    modelId: string;
}

/**
 * Input for updating an MCP server.
 */
export interface UpdateMCPServerInput {
    id: string;
    config: MCPServerConfig;
}

export interface UpdateWorkspaceFileRequest {
    chatId: string;
    path: string;
    content: string;
}

export interface UpdateWorkspaceFileResponse {
    manifestId: string;
    path: string;
}

export interface UploadAttachmentResult {
    id: string;
    type: string;
    name: string;
    mimeType: string;
    size: number;
}

export interface WorkspaceFileRequest {
    chatId: string;
    path: string;
}

export interface WorkspaceFileResponse {
    path: string;
    content: string;
    size: number;
}

export interface WorkspaceFilesChanged {
    chatId: string;
    changedPaths: string[];
    deletedPaths: string[];
}

export interface WorkspaceFilesRequest {
    chatId: string;
}

export interface WorkspaceFilesResponse {
    files: string[];
}

export interface WorkspaceManifestRequest {
    chatId: string;
    manifestId?: string | undefined;
}

export interface WorkspaceManifestResponse {
    id: string;
    chatId: string;
    parentId?: string | undefined;
    files: Record<string, string>;
    createdAt?: string | undefined;
    source: string;
}


// ============ Commands ============

/**
 * Add a new MCP server and connect to it.
 */
export async function addMcpServer(args: { body: AddMCPServerInput }): Promise<MCPServerInfo> {
    const _r = await request("add_mcp_server", { body: args.body });
    return { id: _r.id, status: _r.status, error: _r.error, toolCount: _r.toolCount, tools: _r.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, inputSchema: item.inputSchema, renderer: item.renderer, rendererConfig: item.renderer_config, requiresConfirmation: item.requires_confirmation })), config: _r.config };
}

export async function cancelRun(args: { body: CancelRunRequest }): Promise<unknown> {
    return request("cancel_run", { body: args.body });
}

export async function cleanupPendingUploadsCommand(): Promise<unknown> {
    return request("cleanup_pending_uploads_command", {});
}

export async function clearStreamRecord(args: { body: ClearStreamRequest }): Promise<unknown> {
    return request("clear_stream_record", { body: args.body });
}

/**
 * Complete an OAuth callback.
 */
export async function completeMcpOauthCallback(args: { body: OAuthCallbackInput }): Promise<OAuthCallbackResult> {
    return request("complete_mcp_oauth_callback", { body: args.body });
}

/**
 * Continue incomplete assistant message by creating a sibling branch.
 */
export function continueMessage(args: { body: ContinueMessageRequest }): BridgeChannel<unknown> {
    return createChannel("continue_message", { body: args.body });
}

export async function createChat(args: { body: CreateChatInput }): Promise<ChatData> {
    return request("create_chat", { body: args.body });
}

export async function deleteChat(args: { body: ChatId }): Promise<void> {
    return request("delete_chat", { body: args.body });
}

export async function deletePendingUpload(args: { body: DeletePendingRequest }): Promise<unknown> {
    return request("delete_pending_upload", { body: args.body });
}

/**
 * Edit user message by creating sibling with new content.
 */
export function editUserMessage(args: { body: EditUserMessageRequest }): BridgeChannel<unknown> {
    return createChannel("edit_user_message", { body: args.body });
}

export async function enableToolset(args: { body: EnableToolsetRequest }): Promise<Record<string, unknown>> {
    return request("enable_toolset", { body: args.body });
}

export async function exportToolset(args: { body: ToolsetIdRequest }): Promise<ExportToolsetResponse> {
    return request("export_toolset", { body: args.body });
}

/**
 * Record an OAuth callback failure.
 */
export async function failMcpOauthCallback(args: { body: OAuthCallbackErrorInput }): Promise<OAuthCallbackResult> {
    return request("fail_mcp_oauth_callback", { body: args.body });
}

export async function generateChatTitle(args: { body: ChatId }): Promise<Record<string, unknown>> {
    return request("generate_chat_title", { body: args.body });
}

export async function getActiveStreams(): Promise<ActiveStreamsResponse> {
    return request("get_active_streams", {});
}

export async function getAllChats(): Promise<AllChatsData> {
    return request("get_all_chats", {});
}

export async function getAttachment(args: { body: GetAttachmentInput }): Promise<AttachmentDataResponse> {
    return request("get_attachment", { body: args.body });
}

/**
 * Get auto-title generation settings.
 * 
 * Returns:
 * Auto-title settings including enabled, prompt, and model configuration
 */
export async function getAutoTitleSettings(): Promise<AutoTitleSettings> {
    return request("get_auto_title_settings", {});
}

/**
 * Get list of available models based on configured providers.
 * 
 * Fetches from all enabled providers in parallel for maximum speed.
 * 
 * Returns:
 * List of available models with provider, modelId, displayName, and isDefault
 */
export async function getAvailableModels(): Promise<AvailableModelsResponse> {
    return request("get_available_models", {});
}

export async function getAvailableTools(): Promise<AvailableToolsResponse> {
    const _r = await request("get_available_tools", {});
    return { tools: _r.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, category: item.category, inputSchema: item.inputSchema, renderer: item.renderer, editableArgs: item.editable_args, requiresConfirmation: item.requires_confirmation })) };
}

export async function getChat(args: { body: ChatId }): Promise<Record<string, unknown>> {
    return request("get_chat", { body: args.body });
}

export async function getChatAgentConfig(args: { body: ChatId }): Promise<ChatAgentConfigResponse> {
    return request("get_chat_agent_config", { body: args.body });
}

/**
 * Get the database directory path for file access.
 * 
 * Returns:
 * The absolute path to the database directory
 */
export async function getDbPath(): Promise<DbPathResponse> {
    return request("get_db_path", {});
}

/**
 * Get default tool IDs for new chats.
 * 
 * Returns:
 * List of default tool IDs
 */
export async function getDefaultTools(): Promise<DefaultToolsResponse> {
    return request("get_default_tools", {});
}

/**
 * Get the OAuth status for an MCP server.
 */
export async function getMcpOauthStatus(args: { body: MCPServerId }): Promise<OAuthStatusResult> {
    return request("get_mcp_oauth_status", { body: args.body });
}

/**
 * Get a server's config for editing (unsanitized).
 */
export async function getMcpServerConfig(args: { body: MCPServerId }): Promise<Record<string, unknown>> {
    return request("get_mcp_server_config", { body: args.body });
}

/**
 * Get all MCP servers with their status and tools.
 */
export async function getMcpServers(): Promise<MCPServersResponse> {
    const _r = await request("get_mcp_servers", {});
    return { servers: _r.servers.map((item: unknown) => ({ id: item.id, status: item.status, error: item.error, toolCount: item.toolCount, tools: item.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, inputSchema: item.inputSchema, renderer: item.renderer, rendererConfig: item.renderer_config, requiresConfirmation: item.requires_confirmation })), config: item.config })) };
}

export async function getMessageSiblings(args: { body: GetMessageSiblingsRequest }): Promise<MessageSiblingInfo[]> {
    return request("get_message_siblings", { body: args.body });
}

/**
 * Get all model settings including reasoning capabilities.
 * 
 * Returns:
 * List of model settings with reasoning support flags
 */
export async function getModelSettings(): Promise<AllModelSettingsResponse> {
    return request("get_model_settings", {});
}

/**
 * Get all configured provider settings.
 * 
 * Returns:
 * List of provider configurations
 */
export async function getProviderSettings(): Promise<AllProvidersResponse> {
    return request("get_provider_settings", {});
}

export async function getToolset(args: { body: ToolsetIdRequest }): Promise<ToolsetDetailInfo> {
    const _r = await request("get_toolset", { body: args.body });
    return { id: _r.id, name: _r.name, version: _r.version, description: _r.description, enabled: _r.enabled, userMcp: _r.user_mcp, installedAt: _r.installed_at, sourceType: _r.source_type, toolCount: _r.tool_count, tools: _r.tools.map((item: unknown) => ({ toolId: item.tool_id, name: item.name, description: item.description, requiresConfirmation: item.requires_confirmation, enabled: item.enabled })) };
}

export async function getVersion(): Promise<string> {
    return request("get_version", {});
}

export async function getWorkspaceFile(args: { body: WorkspaceFileRequest }): Promise<WorkspaceFileResponse> {
    return request("get_workspace_file", { body: { chat_id: args.body.chatId, path: args.body.path } });
}

export async function getWorkspaceFiles(args: { body: WorkspaceFilesRequest }): Promise<WorkspaceFilesResponse> {
    return request("get_workspace_files", { body: { chat_id: args.body.chatId } });
}

export async function getWorkspaceManifest(args: { body: WorkspaceManifestRequest }): Promise<WorkspaceManifestResponse> {
    const _r = await request("get_workspace_manifest", { body: { chat_id: args.body.chatId, manifest_id: args.body.manifestId } });
    return { id: _r.id, chatId: _r.chat_id, parentId: _r.parent_id, files: _r.files, createdAt: _r.created_at, source: _r.source };
}

export async function greet(args: { body: Person }): Promise<Greeting> {
    return request("greet", { body: args.body });
}

/**
 * List toolsets, optionally filtered by user_mcp flag.
 */
export async function listToolsets(args: { body?: ListToolsetsRequest }): Promise<ToolsetsResponse> {
    const _r = await request("list_toolsets", { body: args.body != null ? { user_mcp: args.body.userMcp } : undefined });
    return { toolsets: _r.toolsets.map((item: unknown) => ({ id: item.id, name: item.name, version: item.version, description: item.description, enabled: item.enabled, userMcp: item.user_mcp, installedAt: item.installed_at, sourceType: item.source_type, toolCount: item.tool_count })) };
}

/**
 * Check if an MCP server URL requires OAuth.
 */
export async function probeMcpOauth(args: { body: ProbeOAuthInput }): Promise<ProbeOAuthResult> {
    return request("probe_mcp_oauth", { body: args.body });
}

/**
 * Reconnect to a failed or disconnected MCP server.
 */
export async function reconnectMcpServer(args: { body: MCPServerId }): Promise<MCPServerInfo> {
    const _r = await request("reconnect_mcp_server", { body: args.body });
    return { id: _r.id, status: _r.status, error: _r.error, toolCount: _r.toolCount, tools: _r.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, inputSchema: item.inputSchema, renderer: item.renderer, rendererConfig: item.renderer_config, requiresConfirmation: item.requires_confirmation })), config: _r.config };
}

/**
 * Disconnect and remove an MCP server (and its user toolset).
 */
export async function removeMcpServer(args: { body: MCPServerId }): Promise<Record<string, boolean>> {
    return request("remove_mcp_server", { body: args.body });
}

/**
 * Handle user response to thinking tag detection prompt.
 * 
 * If accepted, enables parse_think_tags setting.
 * If declined, stores thinkingTagPrompted: { prompted: true, declined: true } in extra.
 * 
 * Args:
 * body: User's response
 */
export async function respondToThinkingTagPrompt(args: { body: RespondToThinkingTagPromptInput }): Promise<void> {
    return request("respond_to_thinking_tag_prompt", { body: args.body });
}

export async function respondToToolApproval(args: { body: RespondToToolApprovalInput }): Promise<unknown> {
    return request("respond_to_tool_approval", { body: args.body });
}

export function retryMessage(args: { body: RetryMessageRequest }): BridgeChannel<unknown> {
    return createChannel("retry_message", { body: args.body });
}

/**
 * Revoke OAuth tokens for an MCP server.
 */
export async function revokeMcpOauth(args: { body: MCPServerId }): Promise<RevokeOAuthResult> {
    return request("revoke_mcp_oauth", { body: args.body });
}

/**
 * Save auto-title generation settings.
 * 
 * Args:
 * body: Auto-title settings to save
 */
export async function saveAutoTitleSettings(args: { body: SaveAutoTitleSettingsInput }): Promise<void> {
    return request("save_auto_title_settings", { body: args.body });
}

/**
 * Save or update model settings (including reasoning support).
 * 
 * Args:
 * body: Model settings to save
 */
export async function saveModelSettings(args: { body: SaveModelSettingsInput }): Promise<void> {
    return request("save_model_settings", { body: args.body });
}

/**
 * Save or update provider settings.
 * 
 * Args:
 * body: Provider configuration to save
 */
export async function saveProviderSettings(args: { body: SaveProviderConfigInput }): Promise<void> {
    return request("save_provider_settings", { body: args.body });
}

/**
 * Scan external app configs for MCP servers to import.
 */
export async function scanImportSources(): Promise<ScanImportSourcesResponse> {
    return request("scan_import_sources", {});
}

/**
 * Set default tool IDs for new chats.
 * 
 * Args:
 * body: Contains list of tool IDs to set as defaults
 */
export async function setDefaultTools(args: { body: SetDefaultToolsInput }): Promise<void> {
    return request("set_default_tools", { body: args.body });
}

/**
 * Set or update override configuration for a tool.
 * 
 * This allows customizing how a tool appears and behaves without
 * modifying the underlying tool definition. Overrides can set:
 * - renderer and renderer_config for custom UI display
 * - name_override and description_override for display text
 * - requires_confirmation to control approval workflow
 * - enabled to hide/show the tool
 */
export async function setToolOverride(args: { body: SetToolOverrideRequest }): Promise<ToolOverrideResponse> {
    const _r = await request("set_tool_override", { body: { toolset_id: args.body.toolsetId, tool_id: args.body.toolId, renderer: args.body.renderer, renderer_config: args.body.rendererConfig, name_override: args.body.nameOverride, description_override: args.body.descriptionOverride, requires_confirmation: args.body.requiresConfirmation, enabled: args.body.enabled } });
    return { toolsetId: _r.toolset_id, toolId: _r.tool_id, renderer: _r.renderer, rendererConfig: _r.renderer_config, nameOverride: _r.name_override, descriptionOverride: _r.description_override, requiresConfirmation: _r.requires_confirmation, enabled: _r.enabled };
}

/**
 * Start OAuth flow for an MCP server.
 */
export async function startMcpOauth(args: { body: StartOAuthInput }): Promise<StartOAuthResult> {
    return request("start_mcp_oauth", { body: args.body });
}

export function streamChat(args: { body: StreamChatRequest }): BridgeChannel<unknown> {
    return createChannel("stream_chat", { body: args.body });
}

export function subscribeToStream(args: { body: SubscribeToStreamRequest }): BridgeChannel<unknown> {
    return createChannel("subscribe_to_stream", { body: args.body });
}

export async function switchToSibling(args: { body: SwitchToSiblingRequest }): Promise<void> {
    return request("switch_to_sibling", { body: args.body });
}

/**
 * Invoke an MCP tool with arguments and return its output.
 */
export async function testMcpTool(args: { body: TestMCPToolInput }): Promise<TestMCPToolResult> {
    return request("test_mcp_tool", { body: args.body });
}

/**
 * Test if a provider connection is valid.
 * 
 * Uses each provider's built-in test_connection() function
 * which validates credentials and connectivity.
 * 
 * Args:
 * body: Contains provider name to test
 * 
 * Returns:
 * Success status and optional error message
 */
export async function testProvider(args: { body: TestProviderInput }): Promise<TestProviderResponse> {
    return request("test_provider", { body: args.body });
}

export async function toggleChatTools(args: { body: ToggleChatToolsInput }): Promise<void> {
    return request("toggle_chat_tools", { body: args.body });
}

export async function toggleStarChat(args: { body: ChatId }): Promise<ChatData> {
    return request("toggle_star_chat", { body: args.body });
}

export async function uninstallToolset(args: { body: ToolsetIdRequest }): Promise<Record<string, boolean>> {
    return request("uninstall_toolset", { body: args.body });
}

export async function updateChat(args: { body: UpdateChatInput }): Promise<ChatData> {
    return request("update_chat", { body: args.body });
}

export async function updateChatModel(args: { body: UpdateChatModelInput }): Promise<void> {
    return request("update_chat_model", { body: args.body });
}

/**
 * Update an MCP server configuration and reconnect.
 */
export async function updateMcpServer(args: { body: UpdateMCPServerInput }): Promise<MCPServerInfo> {
    const _r = await request("update_mcp_server", { body: args.body });
    return { id: _r.id, status: _r.status, error: _r.error, toolCount: _r.toolCount, tools: _r.tools.map((item: unknown) => ({ id: item.id, name: item.name, description: item.description, inputSchema: item.inputSchema, renderer: item.renderer, rendererConfig: item.renderer_config, requiresConfirmation: item.requires_confirmation })), config: _r.config };
}

export async function updateWorkspaceFile(args: { body: UpdateWorkspaceFileRequest }): Promise<UpdateWorkspaceFileResponse> {
    const _r = await request("update_workspace_file", { body: { chat_id: args.body.chatId, path: args.body.path, content: args.body.content } });
    return { manifestId: _r.manifest_id, path: _r.path };
}

// ============ Uploads ============

export function importToolset(args: { file: File }): UploadHandle<ImportToolsetResult> {
    return createUpload("import_toolset", [args.file], {});
}

export function uploadAttachment(args: { file: File; id: string }): UploadHandle<UploadAttachmentResult> {
    return createUpload("upload_attachment", [args.file], { id: args.id });
}

// ============ WebSockets ============

export interface EventsServerEvents {
    mcp_status: McpServerStatus;
    mcp_servers: McpServersSnapshot;
    workspace_files_changed: WorkspaceFilesChanged;
}

export interface EventsClientEvents {
    ping: Ping;
}

export class EventsSocket {
    private ws: WebSocket | null = null;
    private listeners: Map<string, Set<(data: unknown) => void>> = new Map();
    private connectionListeners: Set<() => void> = new Set();
    private disconnectionListeners: Set<(event: CloseEvent) => void> = new Set();
    private errorListeners: Set<(error: Event) => void> = new Set();

    connect(): void {
        const baseUrl = getBaseUrl().replace(/^http/, 'ws');
        this.ws = new WebSocket(`${baseUrl}/ws/events`);

        this.ws.onopen = () => {
            this.connectionListeners.forEach(cb => cb());
        };

        this.ws.onclose = (event) => {
            this.disconnectionListeners.forEach(cb => cb(event));
        };

        this.ws.onerror = (error) => {
            this.errorListeners.forEach(cb => cb(error));
        };

        this.ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                const eventName = message.event;
                const data = message.data;
                const callbacks = this.listeners.get(eventName);
                if (callbacks) {
                    callbacks.forEach(cb => cb(data));
                }
            } catch (e) {
                console.error('[Zynk] Failed to parse WebSocket message:', e);
            }
        };
    }

    disconnect(): void {
        this.ws?.close();
        this.ws = null;
    }

    get isConnected(): boolean {
        return this.ws?.readyState === WebSocket.OPEN;
    }

    send<K extends keyof EventsClientEvents>(
        event: K,
        data: EventsClientEvents[K]
    ): void {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error('[Zynk] WebSocket is not connected');
        }
        this.ws.send(JSON.stringify({ event, data }));
    }

    on<K extends keyof EventsServerEvents>(
        event: K,
        callback: (data: EventsServerEvents[K]) => void
    ): () => void {
        const eventStr = event as string;
        if (!this.listeners.has(eventStr)) {
            this.listeners.set(eventStr, new Set());
        }
        const cb = callback as (data: unknown) => void;
        this.listeners.get(eventStr)!.add(cb);
        return () => {
            this.listeners.get(eventStr)?.delete(cb);
        };
    }

    onConnect(callback: () => void): () => void {
        this.connectionListeners.add(callback);
        return () => {
            this.connectionListeners.delete(callback);
        };
    }

    onDisconnect(callback: (event: CloseEvent) => void): () => void {
        this.disconnectionListeners.add(callback);
        return () => {
            this.disconnectionListeners.delete(callback);
        };
    }

    onError(callback: (error: Event) => void): () => void {
        this.errorListeners.add(callback);
        return () => {
            this.errorListeners.delete(callback);
        };
    }

    onMcpStatus(callback: (data: McpServerStatus) => void): () => void {
        return this.on("mcp_status", (_d) => callback({ id: _d.id, status: _d.status, error: _d.error, toolCount: _d.tool_count, oauthStatus: _d.oauth_status, oauthProviderName: _d.oauth_provider_name, authHint: _d.auth_hint, config: _d.config }));
    }

    onMcpServers(callback: (data: McpServersSnapshot) => void): () => void {
        return this.on("mcp_servers", (_d) => callback({ servers: _d.servers.map((item: unknown) => ({ id: item.id, status: item.status, error: item.error, toolCount: item.tool_count, oauthStatus: item.oauth_status, oauthProviderName: item.oauth_provider_name, authHint: item.auth_hint, config: item.config })) }));
    }

    onWorkspaceFilesChanged(callback: (data: WorkspaceFilesChanged) => void): () => void {
        return this.on("workspace_files_changed", (_d) => callback({ chatId: _d.chat_id, changedPaths: _d.changed_paths, deletedPaths: _d.deleted_paths }));
    }

    sendPing(data: Ping): void {
        this.send("ping", data);
    }
}

export function createEventsSocket(): EventsSocket {
    return new EventsSocket();
}