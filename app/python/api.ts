/* Auto-generated by Zynk - DO NOT EDIT */
/* Generated: 2025-12-23T21:14:16.302261 */

import { initBridge, request, createChannel, BridgeRequestError } from "./_internal";
import type { BridgeChannel, BridgeError } from "./_internal";

export { initBridge, BridgeRequestError };
export type { BridgeChannel, BridgeError };

// ============ Interfaces ============

/**
 * Input for adding a new MCP server.
 */
export interface AddMCPServerInput {
    id: string;
    config: MCPServerConfig;
}

export interface AgentConfig {
    provider?: string;
    modelId?: string;
    toolIds?: string[];
    instructions?: string[];
    name?: string | undefined;
    description?: string | undefined;
}

export interface AllChatsData {
    chats: Record<string, ChatData>;
}

export interface AllModelSettingsResponse {
    models: ModelSettingsInfo[];
}

export interface AllProvidersResponse {
    providers: ProviderConfig[];
}

export interface AutoTitleSettings {
    enabled?: boolean;
    prompt?: string;
    modelMode?: string;
    provider?: string;
    modelId?: string;
}

export interface AvailableModelsResponse {
    models: ModelInfo[];
}

export interface AvailableToolsResponse {
    tools?: ToolInfo[];
}

export interface CancelRunRequest {
    messageId: string;
}

export interface ChatAgentConfigResponse {
    toolIds: string[];
    provider: string;
    modelId: string;
}

export interface ChatData {
    id?: string | undefined;
    title: string;
    messages?: ChatMessage[];
    model?: string | undefined;
    createdAt?: string | undefined;
    updatedAt?: string | undefined;
}

export interface ChatId {
    id: string;
}

export interface ChatMessage {
    id: string;
    role: string;
    content: string | ContentBlock[];
    createdAt?: string | undefined;
    toolCalls?: ToolCall[] | undefined;
}

export interface ContentBlock {
    type: string;
    content?: string | undefined;
    id?: string | undefined;
    toolName?: string | undefined;
    toolArgs?: Record<string, unknown> | undefined;
    toolResult?: string | undefined;
    isCompleted?: boolean | undefined;
    renderer?: string | undefined;
    requiresApproval?: boolean | undefined;
    approvalId?: string | undefined;
    approvalStatus?: string | undefined;
}

export interface ContinueMessageRequest {
    messageId: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
}

export interface CreateChatInput {
    id?: string | undefined;
    title?: string | undefined;
    model?: string | undefined;
    agentConfig?: AgentConfig | undefined;
}

export interface DefaultToolsResponse {
    toolIds: string[];
}

export interface EditUserMessageRequest {
    messageId: string;
    newContent: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
}

export interface GetMessageSiblingsRequest {
    messageId: string;
}

export interface Greeting {
    message: string;
}

/**
 * Configuration for an MCP server.
 */
export interface MCPServerConfig {
    command?: string | undefined;
    args?: string[] | undefined;
    env?: Record<string, string> | undefined;
    cwd?: string | undefined;
    url?: string | undefined;
    transport?: unknown | undefined;
    headers?: Record<string, string> | undefined;
    requiresConfirmation?: boolean;
    toolOverrides?: Record<string, Record<string, unknown>> | undefined;
}

/**
 * Input containing just a server ID.
 */
export interface MCPServerId {
    id: string;
}

/**
 * Information about an MCP server.
 */
export interface MCPServerInfo {
    id: string;
    status: unknown;
    error?: string | undefined;
    toolCount?: number;
    tools?: MCPToolInfo[];
    config?: Record<string, unknown>;
}

/**
 * Response for get_mcp_servers.
 */
export interface MCPServersResponse {
    servers: MCPServerInfo[];
}

/**
 * Information about an MCP tool.
 */
export interface MCPToolInfo {
    id: string;
    name: string;
    description?: string | undefined;
    inputSchema?: Record<string, unknown> | undefined;
    renderer?: string | undefined;
    editableArgs?: string[] | undefined;
    requiresConfirmation?: boolean;
}

export interface MessageSiblingInfo {
    id: string;
    sequence: number;
    isActive: boolean;
}

export interface ModelInfo {
    provider: string;
    modelId: string;
    displayName: string;
    isDefault?: boolean;
}

export interface ModelSettingsInfo {
    provider: string;
    modelId: string;
    parseThinkTags: boolean;
    reasoning: ReasoningInfo;
    thinkingTagPrompted?: ThinkingTagPromptInfo | undefined;
}

export interface Person {
    name: string;
}

export interface ProviderConfig {
    provider: string;
    apiKey?: string | undefined;
    baseUrl?: string | undefined;
    extra?: unknown | undefined;
    enabled?: boolean;
}

export interface ReasoningInfo {
    supports: boolean;
    isUserOverride: boolean;
}

export interface ReprocessMessageRequest {
    messageId: string;
}

export interface RespondToThinkingTagPromptInput {
    provider: string;
    modelId: string;
    accepted: boolean;
}

export interface RespondToToolApprovalInput {
    runId: string;
    approved: boolean;
    toolDecisions?: Record<string, boolean> | undefined;
    editedArgs?: Record<string, Record<string, unknown>> | undefined;
}

export interface RetryMessageRequest {
    messageId: string;
    chatId: string;
    modelId?: string | undefined;
    toolIds?: string[];
}

export interface SaveAutoTitleSettingsInput {
    enabled: boolean;
    prompt: string;
    modelMode: string;
    provider: string;
    modelId: string;
}

export interface SaveModelSettingsInput {
    provider: string;
    modelId: string;
    parseThinkTags?: boolean;
    reasoning?: ReasoningInfo | undefined;
}

export interface SaveProviderConfigInput {
    provider: string;
    apiKey?: string | undefined;
    baseUrl?: string | undefined;
    extra?: unknown | undefined;
    enabled?: boolean;
}

export interface SetDefaultToolsInput {
    toolIds: string[];
}

export interface StreamChatRequest {
    messages: Record<string, unknown>[];
    modelId?: string | undefined;
    chatId?: string | undefined;
    toolIds?: string[];
}

export interface SwitchToSiblingRequest {
    messageId: string;
    siblingId: string;
    chatId: string;
}

/**
 * Input for testing provider connection.
 */
export interface TestProviderInput {
    provider: string;
}

/**
 * Response from testing provider connection.
 */
export interface TestProviderResponse {
    success: boolean;
    error?: string | undefined;
}

export interface ThinkingTagPromptInfo {
    prompted: boolean;
    declined: boolean;
}

export interface ToggleChatToolsInput {
    chatId: string;
    toolIds: string[];
}

export interface ToolCall {
    id: string;
    toolName: string;
    toolArgs: Record<string, unknown>;
    toolResult?: string | undefined;
    isCompleted?: boolean | undefined;
}

export interface ToolInfo {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    inputSchema?: Record<string, unknown> | undefined;
    renderer?: string | undefined;
    editableArgs?: string[] | undefined;
    requiresConfirmation?: boolean | undefined;
}

export interface UpdateChatInput {
    id: string;
    title?: string | undefined;
    model?: string | undefined;
}

export interface UpdateChatModelInput {
    chatId: string;
    provider: string;
    modelId: string;
}

/**
 * Input for updating an MCP server.
 */
export interface UpdateMCPServerInput {
    id: string;
    config: MCPServerConfig;
}


// ============ Converters ============

function convertAddMCPServerInput(obj: AddMCPServerInput): Record<string, unknown> {
    return {
        id: obj.id,
        config: convertMCPServerConfig(obj.config),
    };
}

function convertAgentConfig(obj: AgentConfig): Record<string, unknown> {
    return {
        provider: obj.provider,
        modelId: obj.modelId,
        toolIds: obj.toolIds,
        instructions: obj.instructions,
        name: obj.name,
        description: obj.description,
    };
}

function convertAllChatsData(obj: AllChatsData): Record<string, unknown> {
    return {
        chats: obj.chats,
    };
}

function convertAllModelSettingsResponse(obj: AllModelSettingsResponse): Record<string, unknown> {
    return {
        models: obj.models.map(convertModelSettingsInfo),
    };
}

function convertAllProvidersResponse(obj: AllProvidersResponse): Record<string, unknown> {
    return {
        providers: obj.providers.map(convertProviderConfig),
    };
}

function convertAutoTitleSettings(obj: AutoTitleSettings): Record<string, unknown> {
    return {
        enabled: obj.enabled,
        prompt: obj.prompt,
        modelMode: obj.modelMode,
        provider: obj.provider,
        modelId: obj.modelId,
    };
}

function convertAvailableModelsResponse(obj: AvailableModelsResponse): Record<string, unknown> {
    return {
        models: obj.models.map(convertModelInfo),
    };
}

function convertAvailableToolsResponse(obj: AvailableToolsResponse): Record<string, unknown> {
    return {
        tools: obj.tools.map(convertToolInfo),
    };
}

function convertCancelRunRequest(obj: CancelRunRequest): Record<string, unknown> {
    return {
        messageId: obj.messageId,
    };
}

function convertChatAgentConfigResponse(obj: ChatAgentConfigResponse): Record<string, unknown> {
    return {
        toolIds: obj.toolIds,
        provider: obj.provider,
        modelId: obj.modelId,
    };
}

function convertChatData(obj: ChatData): Record<string, unknown> {
    return {
        id: obj.id,
        title: obj.title,
        messages: obj.messages.map(convertChatMessage),
        model: obj.model,
        createdAt: obj.createdAt,
        updatedAt: obj.updatedAt,
    };
}

function convertChatId(obj: ChatId): Record<string, unknown> {
    return {
        id: obj.id,
    };
}

function convertChatMessage(obj: ChatMessage): Record<string, unknown> {
    return {
        id: obj.id,
        role: obj.role,
        content: obj.content,
        createdAt: obj.createdAt,
        toolCalls: obj.toolCalls != null ? obj.toolCalls.map(convertToolCall) : obj.toolCalls,
    };
}

function convertContentBlock(obj: ContentBlock): Record<string, unknown> {
    return {
        type: obj.type,
        content: obj.content,
        id: obj.id,
        toolName: obj.toolName,
        toolArgs: obj.toolArgs,
        toolResult: obj.toolResult,
        isCompleted: obj.isCompleted,
        renderer: obj.renderer,
        requiresApproval: obj.requiresApproval,
        approvalId: obj.approvalId,
        approvalStatus: obj.approvalStatus,
    };
}

function convertContinueMessageRequest(obj: ContinueMessageRequest): Record<string, unknown> {
    return {
        messageId: obj.messageId,
        chatId: obj.chatId,
        modelId: obj.modelId,
        toolIds: obj.toolIds,
    };
}

function convertCreateChatInput(obj: CreateChatInput): Record<string, unknown> {
    return {
        id: obj.id,
        title: obj.title,
        model: obj.model,
        agentConfig: obj.agentConfig != null ? convertAgentConfig(obj.agentConfig) : obj.agentConfig,
    };
}

function convertDefaultToolsResponse(obj: DefaultToolsResponse): Record<string, unknown> {
    return {
        toolIds: obj.toolIds,
    };
}

function convertEditUserMessageRequest(obj: EditUserMessageRequest): Record<string, unknown> {
    return {
        messageId: obj.messageId,
        newContent: obj.newContent,
        chatId: obj.chatId,
        modelId: obj.modelId,
        toolIds: obj.toolIds,
    };
}

function convertGetMessageSiblingsRequest(obj: GetMessageSiblingsRequest): Record<string, unknown> {
    return {
        messageId: obj.messageId,
    };
}

function convertGreeting(obj: Greeting): Record<string, unknown> {
    return {
        message: obj.message,
    };
}

function convertMCPServerConfig(obj: MCPServerConfig): Record<string, unknown> {
    return {
        command: obj.command,
        args: obj.args,
        env: obj.env,
        cwd: obj.cwd,
        url: obj.url,
        transport: obj.transport,
        headers: obj.headers,
        requiresConfirmation: obj.requiresConfirmation,
        toolOverrides: obj.toolOverrides,
    };
}

function convertMCPServerId(obj: MCPServerId): Record<string, unknown> {
    return {
        id: obj.id,
    };
}

function convertMCPServerInfo(obj: MCPServerInfo): Record<string, unknown> {
    return {
        id: obj.id,
        status: obj.status,
        error: obj.error,
        toolCount: obj.toolCount,
        tools: obj.tools.map(convertMCPToolInfo),
        config: obj.config,
    };
}

function convertMCPServersResponse(obj: MCPServersResponse): Record<string, unknown> {
    return {
        servers: obj.servers.map(convertMCPServerInfo),
    };
}

function convertMCPToolInfo(obj: MCPToolInfo): Record<string, unknown> {
    return {
        id: obj.id,
        name: obj.name,
        description: obj.description,
        inputSchema: obj.inputSchema,
        renderer: obj.renderer,
        editable_args: obj.editableArgs,
        requires_confirmation: obj.requiresConfirmation,
    };
}

function convertMessageSiblingInfo(obj: MessageSiblingInfo): Record<string, unknown> {
    return {
        id: obj.id,
        sequence: obj.sequence,
        isActive: obj.isActive,
    };
}

function convertModelInfo(obj: ModelInfo): Record<string, unknown> {
    return {
        provider: obj.provider,
        modelId: obj.modelId,
        displayName: obj.displayName,
        isDefault: obj.isDefault,
    };
}

function convertModelSettingsInfo(obj: ModelSettingsInfo): Record<string, unknown> {
    return {
        provider: obj.provider,
        modelId: obj.modelId,
        parseThinkTags: obj.parseThinkTags,
        reasoning: convertReasoningInfo(obj.reasoning),
        thinkingTagPrompted: obj.thinkingTagPrompted != null ? convertThinkingTagPromptInfo(obj.thinkingTagPrompted) : obj.thinkingTagPrompted,
    };
}

function convertPerson(obj: Person): Record<string, unknown> {
    return {
        name: obj.name,
    };
}

function convertProviderConfig(obj: ProviderConfig): Record<string, unknown> {
    return {
        provider: obj.provider,
        apiKey: obj.apiKey,
        baseUrl: obj.baseUrl,
        extra: obj.extra,
        enabled: obj.enabled,
    };
}

function convertReasoningInfo(obj: ReasoningInfo): Record<string, unknown> {
    return {
        supports: obj.supports,
        isUserOverride: obj.isUserOverride,
    };
}

function convertReprocessMessageRequest(obj: ReprocessMessageRequest): Record<string, unknown> {
    return {
        messageId: obj.messageId,
    };
}

function convertRespondToThinkingTagPromptInput(obj: RespondToThinkingTagPromptInput): Record<string, unknown> {
    return {
        provider: obj.provider,
        modelId: obj.modelId,
        accepted: obj.accepted,
    };
}

function convertRespondToToolApprovalInput(obj: RespondToToolApprovalInput): Record<string, unknown> {
    return {
        runId: obj.runId,
        approved: obj.approved,
        toolDecisions: obj.toolDecisions,
        editedArgs: obj.editedArgs,
    };
}

function convertRetryMessageRequest(obj: RetryMessageRequest): Record<string, unknown> {
    return {
        messageId: obj.messageId,
        chatId: obj.chatId,
        modelId: obj.modelId,
        toolIds: obj.toolIds,
    };
}

function convertSaveAutoTitleSettingsInput(obj: SaveAutoTitleSettingsInput): Record<string, unknown> {
    return {
        enabled: obj.enabled,
        prompt: obj.prompt,
        modelMode: obj.modelMode,
        provider: obj.provider,
        modelId: obj.modelId,
    };
}

function convertSaveModelSettingsInput(obj: SaveModelSettingsInput): Record<string, unknown> {
    return {
        provider: obj.provider,
        modelId: obj.modelId,
        parseThinkTags: obj.parseThinkTags,
        reasoning: obj.reasoning != null ? convertReasoningInfo(obj.reasoning) : obj.reasoning,
    };
}

function convertSaveProviderConfigInput(obj: SaveProviderConfigInput): Record<string, unknown> {
    return {
        provider: obj.provider,
        apiKey: obj.apiKey,
        baseUrl: obj.baseUrl,
        extra: obj.extra,
        enabled: obj.enabled,
    };
}

function convertSetDefaultToolsInput(obj: SetDefaultToolsInput): Record<string, unknown> {
    return {
        toolIds: obj.toolIds,
    };
}

function convertStreamChatRequest(obj: StreamChatRequest): Record<string, unknown> {
    return {
        messages: obj.messages,
        modelId: obj.modelId,
        chatId: obj.chatId,
        toolIds: obj.toolIds,
    };
}

function convertSwitchToSiblingRequest(obj: SwitchToSiblingRequest): Record<string, unknown> {
    return {
        messageId: obj.messageId,
        siblingId: obj.siblingId,
        chatId: obj.chatId,
    };
}

function convertTestProviderInput(obj: TestProviderInput): Record<string, unknown> {
    return {
        provider: obj.provider,
    };
}

function convertTestProviderResponse(obj: TestProviderResponse): Record<string, unknown> {
    return {
        success: obj.success,
        error: obj.error,
    };
}

function convertThinkingTagPromptInfo(obj: ThinkingTagPromptInfo): Record<string, unknown> {
    return {
        prompted: obj.prompted,
        declined: obj.declined,
    };
}

function convertToggleChatToolsInput(obj: ToggleChatToolsInput): Record<string, unknown> {
    return {
        chatId: obj.chatId,
        toolIds: obj.toolIds,
    };
}

function convertToolCall(obj: ToolCall): Record<string, unknown> {
    return {
        id: obj.id,
        toolName: obj.toolName,
        toolArgs: obj.toolArgs,
        toolResult: obj.toolResult,
        isCompleted: obj.isCompleted,
    };
}

function convertToolInfo(obj: ToolInfo): Record<string, unknown> {
    return {
        id: obj.id,
        name: obj.name,
        description: obj.description,
        category: obj.category,
        inputSchema: obj.inputSchema,
        renderer: obj.renderer,
        editable_args: obj.editableArgs,
        requires_confirmation: obj.requiresConfirmation,
    };
}

function convertUpdateChatInput(obj: UpdateChatInput): Record<string, unknown> {
    return {
        id: obj.id,
        title: obj.title,
        model: obj.model,
    };
}

function convertUpdateChatModelInput(obj: UpdateChatModelInput): Record<string, unknown> {
    return {
        chatId: obj.chatId,
        provider: obj.provider,
        modelId: obj.modelId,
    };
}

function convertUpdateMCPServerInput(obj: UpdateMCPServerInput): Record<string, unknown> {
    return {
        id: obj.id,
        config: convertMCPServerConfig(obj.config),
    };
}


// ============ Commands ============

/**
 * Add a new MCP server and connect to it.
 * 
 * Args:
 * body: Contains server ID and configuration
 * 
 * Returns:
 * Server info with connection status
 */
export async function addMcpServer(args: { body: AddMCPServerInput }): Promise<MCPServerInfo> {
    return request("add_mcp_server", { body: convertAddMCPServerInput(args.body) });
}

/**
 * Cancel an active streaming run. Returns {cancelled: bool}
 */
export async function cancelRun(args: { body: CancelRunRequest }): Promise<unknown> {
    return request("cancel_run", { body: convertCancelRunRequest(args.body) });
}

/**
 * Continue incomplete assistant message from where it stopped.
 */
export function continueMessage(args: { body: ContinueMessageRequest }): BridgeChannel<unknown> {
    return createChannel("continue_message", { body: convertContinueMessageRequest(args.body) });
}

export async function createChat(args: { body: CreateChatInput }): Promise<ChatData> {
    return request("create_chat", { body: convertCreateChatInput(args.body) });
}

export async function deleteChat(args: { body: ChatId }): Promise<void> {
    return request("delete_chat", { body: convertChatId(args.body) });
}

/**
 * Edit user message by creating sibling with new content.
 */
export function editUserMessage(args: { body: EditUserMessageRequest }): BridgeChannel<unknown> {
    return createChannel("edit_user_message", { body: convertEditUserMessageRequest(args.body) });
}

/**
 * Generate and update title for a chat based on its first message.
 * 
 * Args:
 * body: Contains chatId
 * 
 * Returns:
 * Dict with the new title or None if generation failed
 */
export async function generateChatTitle(args: { body: ChatId }): Promise<Record<string, unknown>> {
    return request("generate_chat_title", { body: convertChatId(args.body) });
}

export async function getAllChats(): Promise<AllChatsData> {
    return request("get_all_chats", {});
}

/**
 * Get auto-title generation settings.
 * 
 * Returns:
 * Auto-title settings including enabled, prompt, and model configuration
 */
export async function getAutoTitleSettings(): Promise<AutoTitleSettings> {
    return request("get_auto_title_settings", {});
}

/**
 * Get list of available models based on configured providers.
 * 
 * Fetches from all enabled providers in parallel for maximum speed.
 * 
 * Returns:
 * List of available models with provider, modelId, displayName, and isDefault
 */
export async function getAvailableModels(): Promise<AvailableModelsResponse> {
    return request("get_available_models", {});
}

/**
 * Get all available tools (builtin and MCP).
 * 
 * Returns:
 * Response with:
 * - tools: Flat list of all tools
 */
export async function getAvailableTools(): Promise<AvailableToolsResponse> {
    return request("get_available_tools", {});
}

export async function getChat(args: { body: ChatId }): Promise<Record<string, unknown>> {
    return request("get_chat", { body: convertChatId(args.body) });
}

/**
 * Get agent configuration for a chat (tools, provider, model).
 * 
 * Args:
 * body: Contains chatId
 * 
 * Returns:
 * Chat's agent configuration
 */
export async function getChatAgentConfig(args: { body: ChatId }): Promise<ChatAgentConfigResponse> {
    return request("get_chat_agent_config", { body: convertChatId(args.body) });
}

/**
 * Get default tool IDs for new chats.
 * 
 * Returns:
 * List of default tool IDs
 */
export async function getDefaultTools(): Promise<DefaultToolsResponse> {
    return request("get_default_tools", {});
}

/**
 * Get all MCP servers with their status and tools.
 * 
 * Returns list of servers including:
 * - Connection status (connecting, connected, error, disconnected)
 * - Error message if status is error
 * - List of available tools for connected servers
 * - Sanitized config (env vars hidden)
 */
export async function getMcpServers(): Promise<MCPServersResponse> {
    return request("get_mcp_servers", {});
}

/**
 * Get all sibling messages for navigation UI.
 */
export async function getMessageSiblings(args: { body: GetMessageSiblingsRequest }): Promise<MessageSiblingInfo[]> {
    return request("get_message_siblings", { body: convertGetMessageSiblingsRequest(args.body) });
}

/**
 * Get all model settings including reasoning capabilities.
 * 
 * Returns:
 * List of model settings with reasoning support flags
 */
export async function getModelSettings(): Promise<AllModelSettingsResponse> {
    return request("get_model_settings", {});
}

/**
 * Get all configured provider settings.
 * 
 * Returns:
 * List of provider configurations
 */
export async function getProviderSettings(): Promise<AllProvidersResponse> {
    return request("get_provider_settings", {});
}

export async function getVersion(): Promise<string> {
    return request("get_version", {});
}

export async function greet(args: { body: Person }): Promise<Greeting> {
    return request("greet", { body: convertPerson(args.body) });
}

/**
 * Reconnect to a failed or disconnected MCP server.
 * 
 * Args:
 * body: Contains server ID
 * 
 * Returns:
 * Server info with new connection status
 */
export async function reconnectMcpServer(args: { body: MCPServerId }): Promise<MCPServerInfo> {
    return request("reconnect_mcp_server", { body: convertMCPServerId(args.body) });
}

/**
 * Disconnect and remove an MCP server.
 * 
 * Args:
 * body: Contains server ID
 * 
 * Returns:
 * Success status
 */
export async function removeMcpServer(args: { body: MCPServerId }): Promise<Record<string, boolean>> {
    return request("remove_mcp_server", { body: convertMCPServerId(args.body) });
}

/**
 * Re-process a message to parse <think> tags from its content.
 * Returns {success: bool}
 */
export async function reprocessMessageThinkTags(args: { body: ReprocessMessageRequest }): Promise<unknown> {
    return request("reprocess_message_think_tags", { body: convertReprocessMessageRequest(args.body) });
}

/**
 * Handle user response to thinking tag detection prompt.
 * 
 * If accepted, enables parse_think_tags and reprocesses the current message.
 * If declined, stores thinkingTagPrompted: { prompted: true, declined: true } in extra.
 * 
 * Args:
 * body: User's response
 */
export async function respondToThinkingTagPrompt(args: { body: RespondToThinkingTagPromptInput }): Promise<void> {
    return request("respond_to_thinking_tag_prompt", { body: convertRespondToThinkingTagPromptInput(args.body) });
}

/**
 * Respond to a tool approval request using Agno's native HITL API.
 * 
 * This stores the approval response and signals the waiting streaming handler
 * to continue the run with updated tool confirmations.
 */
export async function respondToToolApproval(args: { body: RespondToToolApprovalInput }): Promise<unknown> {
    return request("respond_to_tool_approval", { body: convertRespondToToolApprovalInput(args.body) });
}

/**
 * Create sibling message and retry generation.
 */
export function retryMessage(args: { body: RetryMessageRequest }): BridgeChannel<unknown> {
    return createChannel("retry_message", { body: convertRetryMessageRequest(args.body) });
}

/**
 * Save auto-title generation settings.
 * 
 * Args:
 * body: Auto-title settings to save
 */
export async function saveAutoTitleSettings(args: { body: SaveAutoTitleSettingsInput }): Promise<void> {
    return request("save_auto_title_settings", { body: convertSaveAutoTitleSettingsInput(args.body) });
}

/**
 * Save or update model settings (including reasoning support).
 * 
 * Args:
 * body: Model settings to save
 */
export async function saveModelSettings(args: { body: SaveModelSettingsInput }): Promise<void> {
    return request("save_model_settings", { body: convertSaveModelSettingsInput(args.body) });
}

/**
 * Save or update provider settings.
 * 
 * Args:
 * body: Provider configuration to save
 */
export async function saveProviderSettings(args: { body: SaveProviderConfigInput }): Promise<void> {
    return request("save_provider_settings", { body: convertSaveProviderConfigInput(args.body) });
}

/**
 * Set default tool IDs for new chats.
 * 
 * Args:
 * body: Contains list of tool IDs to set as defaults
 */
export async function setDefaultTools(args: { body: SetDefaultToolsInput }): Promise<void> {
    return request("set_default_tools", { body: convertSetDefaultToolsInput(args.body) });
}

export function streamChat(args: { body: StreamChatRequest }): BridgeChannel<unknown> {
    return createChannel("stream_chat", { body: convertStreamChatRequest(args.body) });
}

/**
 * Switch active branch to different sibling.
 */
export async function switchToSibling(args: { body: SwitchToSiblingRequest }): Promise<void> {
    return request("switch_to_sibling", { body: convertSwitchToSiblingRequest(args.body) });
}

/**
 * Test if a provider connection is valid.
 * 
 * Uses each provider's built-in test_connection() function
 * which validates credentials and connectivity.
 * 
 * Args:
 * body: Contains provider name to test
 * 
 * Returns:
 * Success status and optional error message
 */
export async function testProvider(args: { body: TestProviderInput }): Promise<TestProviderResponse> {
    return request("test_provider", { body: convertTestProviderInput(args.body) });
}

/**
 * Update active tools for a chat session.
 * 
 * Args:
 * body: Contains chatId and list of tool IDs to activate
 */
export async function toggleChatTools(args: { body: ToggleChatToolsInput }): Promise<void> {
    return request("toggle_chat_tools", { body: convertToggleChatToolsInput(args.body) });
}

export async function updateChat(args: { body: UpdateChatInput }): Promise<ChatData> {
    return request("update_chat", { body: convertUpdateChatInput(args.body) });
}

/**
 * Switch the model/provider for a chat session.
 * 
 * Args:
 * body: Contains chatId, provider, and modelId
 */
export async function updateChatModel(args: { body: UpdateChatModelInput }): Promise<void> {
    return request("update_chat_model", { body: convertUpdateChatModelInput(args.body) });
}

/**
 * Update an MCP server configuration and reconnect.
 * 
 * Args:
 * body: Contains server ID and new configuration
 * 
 * Returns:
 * Server info with connection status
 */
export async function updateMcpServer(args: { body: UpdateMCPServerInput }): Promise<MCPServerInfo> {
    return request("update_mcp_server", { body: convertUpdateMCPServerInput(args.body) });
}