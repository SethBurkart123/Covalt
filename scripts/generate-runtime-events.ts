import { readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";

interface RuntimeEventEntry {
  key: string;
  name: string;
}

interface RuntimeEventContract {
  version: string;
  events: RuntimeEventEntry[];
  groups?: Record<string, string[]>;
}

function readContract(filePath: string): RuntimeEventContract {
  const raw = readFileSync(filePath, "utf-8");
  const parsed = JSON.parse(raw) as Partial<RuntimeEventContract>;

  if (!parsed || typeof parsed !== "object") {
    throw new Error("Runtime event contract must be a JSON object");
  }
  if (typeof parsed.version !== "string" || !parsed.version.trim()) {
    throw new Error("Runtime event contract requires a non-empty version");
  }
  if (!Array.isArray(parsed.events)) {
    throw new Error("Runtime event contract requires an events array");
  }

  const seenKeys = new Set<string>();
  const seenNames = new Set<string>();
  const events: RuntimeEventEntry[] = parsed.events.map((event) => {
    if (!event || typeof event !== "object") {
      throw new Error("Runtime event entries must be objects");
    }

    const key = (event as RuntimeEventEntry).key;
    const name = (event as RuntimeEventEntry).name;

    if (typeof key !== "string" || !key.trim()) {
      throw new Error("Runtime event entry key must be a non-empty string");
    }
    if (typeof name !== "string" || !name.trim()) {
      throw new Error("Runtime event entry name must be a non-empty string");
    }
    if (seenKeys.has(key)) {
      throw new Error(`Duplicate runtime event key: ${key}`);
    }
    if (seenNames.has(name)) {
      throw new Error(`Duplicate runtime event name: ${name}`);
    }

    seenKeys.add(key);
    seenNames.add(name);
    return { key, name };
  });

  const groupsInput = parsed.groups ?? {};
  if (typeof groupsInput !== "object" || Array.isArray(groupsInput)) {
    throw new Error("Runtime event contract groups must be an object");
  }

  const groups: Record<string, string[]> = {};
  for (const [groupName, keys] of Object.entries(groupsInput)) {
    if (!Array.isArray(keys) || !keys.every((key) => typeof key === "string" && key.trim())) {
      throw new Error(`Runtime event group '${groupName}' must be an array of non-empty strings`);
    }
    for (const key of keys) {
      if (!seenKeys.has(key)) {
        throw new Error(`Runtime event group '${groupName}' references unknown key: ${key}`);
      }
    }
    groups[groupName] = [...keys];
  }

  return {
    version: parsed.version,
    events,
    groups,
  };
}

function renderRuntimeEventsTs(contract: RuntimeEventContract): string {
  const indent = (value: string) => `  ${value}`;

  const eventObjectLines = contract.events.map((event) => indent(`${event.key}: "${event.name}",`));

  const knownEventLines = contract.events.map((event) => indent(`RUNTIME_EVENT.${event.key},`));

  const mapGroup = (groupName: string) => {
    const keys = contract.groups?.[groupName] ?? [];
    return keys.map((key) => indent(`RUNTIME_EVENT.${key},`));
  };

  const terminalLines = mapGroup("terminal");
  const toolLines = mapGroup("tool");
  const memberLines = mapGroup("member");
  const flowNodeLines = mapGroup("flowNode");

  return `// AUTO-GENERATED by scripts/generate-runtime-events.ts from contracts/runtime-events.v1.json\n// DO NOT EDIT MANUALLY\n\nexport const RUNTIME_EVENT_CONTRACT_VERSION = "${contract.version}" as const;\n\nexport const RUNTIME_EVENT = {\n${eventObjectLines.join("\n")}\n} as const;\n\nexport type RuntimeEventName = (typeof RUNTIME_EVENT)[keyof typeof RUNTIME_EVENT];\n\nexport const KNOWN_RUNTIME_EVENTS: readonly RuntimeEventName[] = [\n${knownEventLines.join("\n")}\n] as const;\n\nconst KNOWN_RUNTIME_EVENT_SET = new Set<string>(KNOWN_RUNTIME_EVENTS);\nconst TERMINAL_RUNTIME_EVENT_SET = new Set<string>([\n${terminalLines.join("\n")}\n]);\nconst TOOL_RUNTIME_EVENT_SET = new Set<string>([\n${toolLines.join("\n")}\n]);\nconst MEMBER_RUNTIME_EVENT_SET = new Set<string>([\n${memberLines.join("\n")}\n]);\nconst FLOW_NODE_RUNTIME_EVENT_SET = new Set<string>([\n${flowNodeLines.join("\n")}\n]);\n\nexport function isKnownRuntimeEvent(event: string): event is RuntimeEventName {\n  return KNOWN_RUNTIME_EVENT_SET.has(event);\n}\n\nexport function isTerminalRuntimeEvent(event: string): boolean {\n  return TERMINAL_RUNTIME_EVENT_SET.has(event);\n}\n\nexport function isToolRuntimeEvent(event: string): boolean {\n  return TOOL_RUNTIME_EVENT_SET.has(event);\n}\n\nexport function isMemberRuntimeEvent(event: string): boolean {\n  return MEMBER_RUNTIME_EVENT_SET.has(event);\n}\n\nexport function isFlowNodeRuntimeEvent(event: string): boolean {\n  return FLOW_NODE_RUNTIME_EVENT_SET.has(event);\n}\n`;
}

function main(): void {
  const repoRoot = resolve(import.meta.dir, "..");
  const contractPath = resolve(repoRoot, "contracts", "runtime-events.v1.json");
  const outputPath = resolve(repoRoot, "app", "lib", "services", "runtime-events.ts");

  const contract = readContract(contractPath);
  const rendered = renderRuntimeEventsTs(contract);
  writeFileSync(outputPath, rendered, "utf-8");
}

main();
